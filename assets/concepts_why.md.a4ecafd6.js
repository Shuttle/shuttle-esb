import { _ as _export_sfc, c as createElementBlock, b as createBaseVNode, d as createTextVNode, t as toDisplayString, a as createStaticVNode, o as openBlock } from "./app.c706ac22.js";
const __pageData = '{"title":"Why use a service bus?","description":"","frontmatter":{},"headers":[{"level":2,"title":"Core","slug":"core"},{"level":2,"title":"Messages","slug":"messages"},{"level":2,"title":"Queues","slug":"queues"},{"level":2,"title":"Service bus","slug":"service-bus"},{"level":2,"title":"Message Types","slug":"message-types"},{"level":3,"title":"Command message","slug":"command-message"},{"level":3,"title":"Starting a process","slug":"starting-a-process"},{"level":3,"title":"Lower-level functions (RPC)","slug":"lower-level-functions-rpc"},{"level":3,"title":"Event message","slug":"event-message"},{"level":3,"title":"Document message","slug":"document-message"},{"level":2,"title":"Coupling","slug":"coupling"},{"level":3,"title":"Behavioural coupling","slug":"behavioural-coupling"},{"level":3,"title":"Temporal coupling","slug":"temporal-coupling"}],"relativePath":"concepts/why.md"}';
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="why-use-a-service-bus" tabindex="-1">Why use a service bus? <a class="header-anchor" href="#why-use-a-service-bus" aria-hidden="true">#</a></h1><p>A service bus provides a mechanism to decouple systems. One system should not have any knowledge of the internal workings of another. The way a service bus manages to do this is by using a messaging infrastructure in the form of queues.</p><p>You certainly can code directly against the messaging infrastructure and you will find that there are pros and cons w.r.t. each transport. There are many decisions that you will need to make along the way and this is where a service bus will make your implementation somewhat easier.</p><p>Developing directly against the queuing system will inevitably lead to various abstractions that you will require to prevent duplication.</p><p>A service bus will provide opinions/implementations for:</p><ul><li>Message delivery: <ul><li>exactly-once (distributed transactions - distributed transactions are not supported by all queuing systems)</li><li>at-least once (non-transactional)</li></ul></li><li>Retrying failed messages</li><li>Request / Response</li><li>Message distribution</li><li>Publish/Subscribe (probably quite easy with RabbitMQ directly, not so much with MSMQ directly)</li><li>Message idempotence</li><li>Dependency injection</li><li>Process management</li></ul><p>A service bus will buy you quite a bit out-of=the-box whereas coding against the queues directly may be a bit of work to get going.</p><p>The following provides a quick overview of some service bus concepts as implemented in Shuttle.Esb that may help you along the way.</p><h2 id="core" tabindex="-1">Core <a class="header-anchor" href="#core" aria-hidden="true">#</a></h2><p>The basic parts of Shuttle.Esb consist of:</p><ul><li>Messages</li><li>Queues</li><li>Service bus</li></ul><p>Every service bus instance is associated with, and therefore processes, only one input queue. This is the inbox. All messages received in the inbox are processed by the associated service bus instance.</p><h2 id="messages" tabindex="-1">Messages <a class="header-anchor" href="#messages" aria-hidden="true">#</a></h2><p>Messages are essentially data transfer objects that implement a specific message structure, e.g.:</p><div class="language-c#"><pre><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ActivateMemberCommand</span></span>\n<span class="line"><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">string</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MemberId</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">get</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">set</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MemberActivatedEvent</span></span>\n<span class="line"><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">string</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MemberId</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">get</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">set</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><h2 id="queues" tabindex="-1">Queues <a class="header-anchor" href="#queues" aria-hidden="true">#</a></h2><p>Messages are processed by message handlers that are invoked by Shuttle.Esb. When a service bus is started it starts listening for messages in an inbox queue. Messages have to end up in the relevant queue to be processed. The inbox configuration is specified in the application configuration file.</p><p>The approach taken is an <strong>at-least-once</strong> delivery mechanism. This differs from an <strong>exactly-once</strong> delivery in that edge cases may result in a message being processed more than once (these should hardly ever occur). For <strong>exactly-once</strong> delivery edge cases may result in message loss which is impossible to find since a duplicate message is easier to spot than no message at all.</p><p>It is important to note that all queues are non-destructive and should always be implemented with acknowledgement in mind. As soon as a message is retrieved from the queue it should be possible to either acknowledge the message to release the message back onto the queue.</p><h2 id="service-bus" tabindex="-1">Service bus <a class="header-anchor" href="#service-bus" aria-hidden="true">#</a></h2><p>A service bus instance is required in every application that accesses the service bus. To configure the service bus a combination of code, the application configuration file, and custom components is used, e.g.:</p><div class="language-c#"><pre><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Host</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IServiceHost</span></span>\n<span class="line"><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IServiceBus</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">_bus</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Start</span><span style="color:#89DDFF;">()</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F78C6C;">var</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">container</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WindsorComponentContainer</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WindsorContainer</span><span style="color:#89DDFF;">());</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">        container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">RegisterServiceBus</span><span style="color:#89DDFF;">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">        _bus </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Resolve</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">IServiceBus</span><span style="color:#89DDFF;">&gt;().</span><span style="color:#82AAFF;">Start</span><span style="color:#89DDFF;">();</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Stop</span><span style="color:#89DDFF;">()</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">        _bus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Dispose</span><span style="color:#89DDFF;">();</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div>', 22);
const _hoisted_23 = /* @__PURE__ */ createTextVNode("A service bus instance is created and started on application startup and disposed on exit. A service bus can be hosted in any type of application but the most typical scenario is to host them as services. Although you ");
const _hoisted_24 = /* @__PURE__ */ createBaseVNode("em", null, "can", -1);
const _hoisted_25 = /* @__PURE__ */ createStaticVNode('<h2 id="message-types" tabindex="-1">Message Types <a class="header-anchor" href="#message-types" aria-hidden="true">#</a></h2><h3 id="command-message" tabindex="-1">Command message <a class="header-anchor" href="#command-message" aria-hidden="true">#</a></h3><p>A command message is used to tell another system or component what to do. This implies that the calling system is aware of the behaviour of the called system. There is, therefore, a high degree of [behavioural coupling].</p><p>A command message always <em><strong>belongs</strong></em> to a single endpoint. Sending a command will never result in the message going to more than <strong>one</strong> queue.</p><h3 id="starting-a-process" tabindex="-1">Starting a process <a class="header-anchor" href="#starting-a-process" aria-hidden="true">#</a></h3><p>There are situations where we need to <em>start</em> something off. Let&#39;s take the case of receiving an order from a client. In our application we would send a <strong>CreateOrderCommand</strong> to our order service. This would kick off the relevant processs.</p><p>So from the client code:</p><div class="language-c#"><pre><code><span class="line"><span style="color:#A6ACCD;">bus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Send</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CreateOrderCommand</span><span style="color:#A6ACCD;"> </span></span>\n<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">            Name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ClientName</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">            Product </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ProductXYZ</span><span style="color:#89DDFF;">&quot;</span></span>\n<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">});</span></span>\n<span class="line"></span></code></pre></div><p>The call would fail if there is nowhere to send the message.</p><p>We could publish an event such as <strong>OrderReceivedEvent</strong> and our order service could subscribe to the event.</p><div class="language-c#"><pre><code><span class="line"><span style="color:#A6ACCD;">bus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Publish</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OrderReceivedEvent</span></span>\n<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">            Name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ClientName</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">            Product </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ProductXYZ</span><span style="color:#89DDFF;">&quot;</span></span>\n<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">});</span></span>\n<span class="line"></span></code></pre></div><p>The call would not fail should there be no subscribers.</p><p>The difference lies purely in the intent of the message. When we can use events they should be preferred but when certain actions are <strong>required</strong> in the system a command may be better suited. Of course, even when using a command approach there may still be some other system interested in knowing that an order has been received and the order service would still publish the event.</p><h3 id="lower-level-functions-rpc" tabindex="-1">Lower-level functions (RPC) <a class="header-anchor" href="#lower-level-functions-rpc" aria-hidden="true">#</a></h3><p>In some situations an event will not be able to relay the intent of any particular action. For instance, we may need to send an e-mail to a manager whenever an order is created (or when the total amount of the order exceeds a set limit). The e-mail service responsible for sending e-mails via our smtp server will not be able to subscribe to the <code>OrderReceivedEvent</code> since the e-mail system would need to be adapted to accomodate rules from another system.</p><p>In this case the e-mail system is responsible for sending e-mails. Any system that would like to send a mail will need to decide when to do so. Therefore, the order service would send a <em>command</em> to the e-mail service:</p><div class="language-c#"><pre><code><span class="line"><span style="color:#A6ACCD;">bus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Send</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SendMailCommand</span></span>\n<span class="line"><span style="color:#A6ACCD;">             </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">                 To </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">manager@ordercompany.co.za</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">                 From </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">orderservice@ordercompany.co.za</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">                 Subject </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Important Order Received</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">                 Body </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Order Details</span><span style="color:#89DDFF;">&quot;</span></span>\n<span class="line"><span style="color:#A6ACCD;">             </span><span style="color:#89DDFF;">});</span></span>\n<span class="line"></span></code></pre></div><h3 id="event-message" tabindex="-1">Event message <a class="header-anchor" href="#event-message" aria-hidden="true">#</a></h3><p>An event message is used to notify any subscribed components that something significant to the business has taken place. Each endpoint subscribed to an event will get a copy of the event message. If no subscribers exist for an event then publishing the event will have no effect.</p><h3 id="document-message" tabindex="-1">Document message <a class="header-anchor" href="#document-message" aria-hidden="true">#</a></h3><p>A document message is used to simply send data to an endpoint. As with the event message it carries no intent and the recipient may do with it as it pleases. This does not meean that data will be sent to an endpoint for no reason. An endpoint may request a document from some service. Or data is automatically sent to some endpoint since it may be a requirement.</p><p><em>Document messages are not implemented in Shuttle.Esb.</em></p><h2 id="coupling" tabindex="-1">Coupling <a class="header-anchor" href="#coupling" aria-hidden="true">#</a></h2><h3 id="behavioural-coupling" tabindex="-1">Behavioural coupling <a class="header-anchor" href="#behavioural-coupling" aria-hidden="true">#</a></h3><p>Behavioural coupling refers to THE degree one system is aware of the behaviour of another. When a command is sent to a system you expect it to behave in a particular way. This represents a high degree of behavioural coupling. When an event message is published there is no expectation from any subscriber to react in any specific way. This is a low degree of behavioural coupling.</p><p>It is conceivable that there may be an expectation that an event will result in a particular outcome in which case the behavioural coupling increases again.</p><h3 id="temporal-coupling" tabindex="-1">Temporal coupling <a class="header-anchor" href="#temporal-coupling" aria-hidden="true">#</a></h3><p>Temporal coupling refers to the availability of services <strong>when</strong> they are required.</p><p>Should <em>ServiceA</em> require <em>ServiceB</em> to be available for <em>ServiceA</em> to function there is a high degree of temporal coupling. Conversely, if <em>ServiceA</em> can continue to operate even though <em>ServiceB</em> is down then there is a low degree of temporal coupling.</p><p>A synchronous web-service call is an example of high temporal coupling.</p><p>Now you may be wondering how <em>ServiceA</em> can continue to operate even though it requires <em>ServiceB</em> to perform some function. The answer is asynchronous communication using queues. One may argue that a web-service call may be made asynchronously but there is a difference. <em>ServiceA</em> may go down before a required response is received resulting in the web-service call failing.</p><p>With messages things always move in one direction at a time. <em>ServiceA</em> to <em>ServiceB</em> is one operation and will eventually complete. <em>ServiceB</em> to <em>ServiceA</em> is another movement and will eventually complete.</p>', 32);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    createBaseVNode("p", null, [
      _hoisted_23,
      _hoisted_24,
      createTextVNode(" write your own service to host your service bus it is not a requirement since you may want to make use of the [generic service host](" + toDisplayString("/generic-host/index.html" | _ctx.relative_url) + ").", 1)
    ]),
    _hoisted_25
  ]);
}
var why = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { __pageData, why as default };
