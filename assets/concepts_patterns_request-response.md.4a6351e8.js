import { _ as _export_sfc, o as openBlock, c as createElementBlock, a as createStaticVNode } from "./app.ab452b29.js";
const _imports_0 = "/shuttle-esb/images/request-response.png";
const __pageData = JSON.parse('{"title":"Request / Response","description":"","frontmatter":{},"headers":[],"relativePath":"concepts/patterns/request-response.md"}');
const _sfc_main = { name: "concepts/patterns/request-response.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="request-response" tabindex="-1">Request / Response <a class="header-anchor" href="#request-response" aria-hidden="true">#</a></h1><p>For some background on <strong>Request/Response</strong> messaging pattern you can have a look at the <a href="http://en.wikipedia.org/wiki/Request-response" target="_blank" rel="noreferrer">Wikipedia article</a>.</p><p><img src="' + _imports_0 + '" alt="Request/Response Image"></p><p>To request an endpoint to perform a certain function you send a command message:</p><div class="language-c#"><button class="copy"></button><span class="lang">c#</span><pre><code><span class="line"><span style="color:#A6ACCD;">bus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Send</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">RequestMessage</span><span style="color:#89DDFF;">());</span></span>\n<span class="line"></span></code></pre></div><p>Although this is a very simple pattern it results in rather tight behavioural coupling. This is not necessarily a bad thing and in many instances it is definitely required.</p><p>Typically the message handler for the command message goes about its business and processes the message. But there will be times when a response is required.</p><p>The response can then be a command message or an event message and you can simply call the <strong>reply</strong> method on the service bus instance:</p><div class="language-c#"><button class="copy"></button><span class="lang">c#</span><pre><code><span class="line"><span style="color:#A6ACCD;">bus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Send</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ResponseMessage</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">builder</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=&gt;</span><span style="color:#A6ACCD;"> builder</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Reply</span><span style="color:#89DDFF;">());</span></span>\n<span class="line"></span></code></pre></div><p>The response may, of course, be decoupled by publishing an event message but it is up to the implementor to decide the mechanism. This would then no longer be request/response but rather publish/subscribe. The advantage of request/response is that it provides the ability to respond to the caller directly whereas publishing a message would result in <strong>all</strong> publishers receiving a copy of the message.</p><p>All message sending in Shuttle.Esb is uni-directional. This means that a message will be displatched to the receipient queue where is will be processed by a message handler. That message handler can then decide whether to respond by sending another message back (uni-directional) to the sender&#39;s work queue, or perhaps publish an event, or even do nothing.</p>', 11);
const _hoisted_12 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_12);
}
const requestResponse = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  requestResponse as default
};
