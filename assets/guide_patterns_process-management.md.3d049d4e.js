import { _ as _export_sfc, c as createElementBlock, o as openBlock, a as createStaticVNode } from "./app.2d1f51b6.js";
const __pageData = '{"title":"Process Management","description":"","frontmatter":{},"headers":[{"level":2,"title":"Front-End (site.canjs)","slug":"front-end-site-canjs"},{"level":2,"title":"Database","slug":"database"},{"level":2,"title":"Process","slug":"process"}],"relativePath":"guide/patterns/process-management.md"}';
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="process-management" tabindex="-1">Process Management <a class="header-anchor" href="#process-management" aria-hidden="true">#</a></h1><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Remember that you can download the samples from the <a href="https://github.com/Shuttle/Shuttle.Esb.Samples" target="_blank">GitHub repository</a>.</p></div><p>Our sample case is a fictitious online book store where you can order books. An order allows you 20 seconds to cancel the order before it is accepted.</p><p>The process management sample represents something closer to a real-world scenario where one would have a front-end integrating with a web-api. The web-api issues commands that are processed by the process managers.</p><p>In this sample the front-end is a static <a href="https://vuejs.org/" target="_blank" rel="noopener noreferrer">Vue.js</a>. The REST API is an <code>dotnet</code> web-api. There are three physical implementations of the same logical process manager to demonstrate the various options and the read-model is kept updated using CQRS with system messages. For the event-sourcing side one could just as easily use event processing to update the read model but since the system event messages are being processed it is re-used for the event sourcing implementation also.</p><p>Once you have opened the <code>Shuttle.ProcessManagement.sln</code> solution in Visual Studio set the following projects as startup projects:</p><ul><li>Shuttle.EMailSender.Server</li><li>Shuttle.Invoicing.Server</li><li>Shuttle.Ordering.Server</li><li>Shuttle.Process.Custom.Server</li><li>Shuttle.Process.CustomES.Server</li><li>Shuttle.Process.ESModule.Server</li><li>Shuttle.Process.QueryServer</li><li>Shuttle.ProcessManagement.WebApi</li></ul><h2 id="front-end-site-canjs" tabindex="-1">Front-End (site.canjs) <a class="header-anchor" href="#front-end-site-canjs" aria-hidden="true">#</a></h2><p>In order to run the single-page application CanJS front-end you need to host the site using any hosting software. A simple solution is using node.js and installing the <code>http-server</code> package. You can then host the site from the <code>site.canjs</code> folder by opening a command prompt and running <code>http-server</code> in the <code>site.canjs</code> folder.</p><p>You will also need to create and configure a Sql Server database for this sample and remember to update the <strong>App.config</strong> <code>connectionString</code> settings to point to your database. Please reference the <strong>Database</strong> section below.</p><h2 id="database" tabindex="-1">Database <a class="header-anchor" href="#database" aria-hidden="true">#</a></h2><p>We need a store for our subscriptions. In this example we will be using <strong>Sql Server</strong>. If you use the express version remember to change the <code>data source</code> value to <code>.\\sqlexpress</code> from the standard <code>.</code>.</p><p>The <code>Shuttle.Esb.SqlServer</code> package contains a number of scripts in the following folder:</p><ul><li><code>.\\Shuttle.PublishSubscribe\\packages\\Shuttle.Esb.SqlServer.{version}\\scripts</code></li></ul><p>The <code>{version}</code> bit will be in a <code>semver</code> format.</p><blockquote><p>Create a new database called <strong>ProcessManagement</strong> and execute script <code>SubscriptionManagerCreate.sql</code> in the newly created database.</p></blockquote><p>This will create the required structures that the subscription manager can use to publish messages.</p><p>The <code>Shuttle.Recall.SqlServer</code> package contains a the following script folder:</p><ul><li><code>.\\Shuttle.PublishSubscribe\\packages\\Shuttle.Recall.SqlServer.{version}\\scripts</code></li></ul><p>The <code>{version}</code> bit will be in a <code>semver</code> format.</p><blockquote><p>Execute script <code>EventStoreCreate.sql</code> in the <code>ProcessManagement</code> database.</p></blockquote><p>This will create the relevant structures used by the <code>Shuttle.Recall</code> event-sourcing mechanism.</p><p>In addition to this the actual process management application also requires some structures that need to be created:</p><blockquote><p>Execute script &#39;{extraction-folder}\\Shuttle.Esb.Samples\\Shuttle.ProcessManagement.scripts\\process-management.sql&#39; in the <code>ProcessManagement</code> database.</p></blockquote><p>You should now be able to run the application.</p><h2 id="process" tabindex="-1">Process <a class="header-anchor" href="#process" aria-hidden="true">#</a></h2><p>Once you add books to your order you can place the order using any of the following processes:</p><ul><li>Custom <ul><li>A hand-rolled process manager storing the process state in custom tables. This is a more traditional approach to data access.</li></ul></li><li>Custom / EventSource <ul><li>A hand-rolled process manager that stored the process state using the <code>Shuttle.Recall</code> event sourcing mechanism directly.</li></ul></li><li>EventSource / Module <ul><li>This uses the <code>Shuttle.Esb.Process</code> module to handle the process state storage for you.</li></ul></li></ul><p>Once you register an order by clicking on the button the <code>RegisterOrderProcessCommand</code> is immeditely sent to the relevant endpoint for processing. An <code>AcceptOrderProcessCommand</code> is then sent locally (to the same endpoint) but it is deferred for 20 seconds. This allows you time to cancel the order.</p><p>The handler processing the <code>AcceptOrderProcessCommand</code> will simply ignore the message should the process/order have been cancelled in the meantime; else it sends a <code>CreateOrderCommand</code> to the order processing endpoint. Once the order has been created the process manager receives an <code>OrderCreatedEvent</code> and it then sends a <code>CreateInvoiceCommand</code> command.</p><p>When the process manager receives the <code>InvoiceCreatedEvent</code> an e-mail needs to be sent to the customer so a <code>SendEMailCommand</code> is sent to the e-mail server endpoint. Once the <code>EMailSentEvent</code> is recevied by the process manager a <code>CompleteOrderProcessCommand</code> is sent locally that then results in an <code>OrderProcessCompletedEvent</code> event.</p><p>After the process has been completed it is possible to <code>Archive</code> the process. In our sample it simply deletes the order.</p><p>As you can see from all the messages the process manager is responsible for the interaction between the various business and infrastructure endpoints to ensure that your use-case runs to completion. None of the systems know about the inner working of another and can be re-used in different processes.</p>', 33);
const _hoisted_34 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_34);
}
var processManagement = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { __pageData, processManagement as default };
